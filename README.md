# Image-Denoising-using-Cpp-and-Rust
## Problem Statement:
The primary objective of this project is to implement image denoising using the median filter technique in both C++ and Rust programming languages. The project aims to assess and compare the performance, readability, and efficiency of the two implementations. Input images in the Portable Gray Map (PGM) format will be provided, and the goal is to develop denoised images while considering execution time, memory usage, and code readability in both languages.

### POPL Angle:
The POPL (Principles of Programming Languages) angle in this project lies in the adherence to fundamental programming principles in both C++ and Rust. Key aspects include data parallelism, immutability, proper error handling, use of functional programming constructs, modularity, and type safety. The project aligns with the principles of writing readable, maintainable, and efficient code while utilizing the features specific to each language.

### Previous Solutions:
While image denoising with median filters is a well-explored problem, the project's focus on comparing implementations in C++ and Rust provides a unique angle. While similar tasks may have been addressed previously, the specific comparison between these two languages for image denoising using median filters may not have been extensively explored.

### Differences in Solution:
The project differentiates itself by implementing the same image denoising technique in both C++ and Rust, facilitating a direct comparison. The differences will be highlighted in terms of language-specific features, syntax, memory management, and overall coding practices. Any optimizations made for each language will be documented, providing valuable insights into the strengths and weaknesses of the respective implementations.

### Challenges Faced:
The challenges encountered during the project may include language-specific difficulties, optimization trade-offs, and adapting the algorithm to the idioms of C++ and Rust. Differences in memory management and performance considerations specific to each language may pose challenges that will be documented and analyzed in the comparative study.

### Expected Deliverables:
1. Implementation of the median filter for image denoising in C++.
2. Implementation of the median filter for image denoising in Rust.
3. Denoised images generated by both implementations.
4. Comparative analysis report covering performance metrics, code readability, and language-specific considerations.
5. Documentation outlining the algorithms, data structures, and language-specific features utilized in each implementation.


## Software architecture:

The software architecture for the image denoising project can follow a modular structure, separating concerns for input/output, image processing, and comparison analysis.

1. Input/Output Module:
   - Responsible for handling file I/O operations, reading input images, and saving denoised images.
   - May include components for reading PGM files and writing denoised images in PGM format.

2. Image Processing Module:
   - Implements the median filter algorithm for image denoising.
   - Modified the existing median filter algorithm with higher performance results.
   - Separates the algorithmic logic from I/O operations for better modularity.
   - Handles the core functionality of processing pixels and applying the median filter.

3. Comparison Analysis Module:
   - Evaluates and compares performance metrics, code readability, and efficiency between C++ and Rust implementations.
   - Gathers data on execution time, memory usage, and any language-specific features used in each implementation.

4. Testing Component:
   - Can be a separate module or part of the Image Processing Module.
   - Involves unit tests for individual functions/methods, integration tests for modules, and possibly benchmarking for performance evaluation.
   - Testing can be both local and, if applicable, remote (especially for performance tests).

5. Reusability:
   - The input/output handling components (reading/writing PGM files) can be reused from existing libraries or code snippets.
   - If there are established median filter libraries in C++ or Rust, they can be used or adapted for the project.
   - Language-agnostic algorithms for image processing may be reusable between the C++ and Rust implementations.

6. Testing Component Placement:
   - Unit tests can be run locally during development to ensure the correctness of individual functions.
   - Integration tests, especially those involving multiple modules, can be run locally.
   - Performance tests may involve remote testing to evaluate the software's behavior under different conditions.


##   POPL Aspects:
Here are some points related to POPL (Principles of Programming Languages) aspects in the provided code:

1. Ownership and Mutability:
   - Lines 9-12: Creation of mutable vectors (`arra` and `arr`) demonstrates ownership and mutability in managing image data.

2. File Handling and Error Handling:
   - Lines 14-16, 26, 34, 43: File handling and error handling using the `Result` type on functions (`File::open`, `writeln!`) demonstrate practical IO operations.

3. Lifetimes:
   - Lifetimes are implicit in the use of references and borrows throughout the code, especially in the file reader (`lines` iterator).

4. Pattern Matching :
   - Line 20: The use of pattern matching to check the file version ("P2") demonstrates Rust's pattern matching for control flow.

5. Iterators and Looping:
   - Lines 28-76: Iterating through file lines using `lines()` iterator and various `for` loops showcases Rust's iterator pattern.

6. Array Indexing and Range:
   - Lines 76-94: Array indexing (`arra[row][col]`) and range usage (`1..=numrows`, `1..=numcols`) demonstrate Rust's array manipulation.

7. Sorting and Mutable Borrowing:
   - Lines 96-104: Sorting of the `window` array demonstrates a practical application of sorting in Rust. Mutable borrowing is used to update the original array.

8.Error Reporting and Logging: 
  - Lines 18, 32: The use of `eprintln!` for error reporting and `println!` for general logging provides a way to communicate with the user.

9. Performance Measurement:
    - Lines 94-104, 112-118: The use of `Instant` to measure execution time and printing the elapsed time demonstrates Rust's focus on performance.

Difficulties faced:
One of the primary challenges we encountered during the development process was related to dataset preparation, particularly in generating the appropriate dataset for our code. The task involved resizing .pgm and .pnm image files to fit the requirements of our project. Initially, this proved to be a complex undertaking due to the unique nature of these file formats. We also had to install external software like GIMP to open such file extensions. 

