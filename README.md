# Image-Denoising-using-`CPP`-and-`Rust`
## Problem Statement:
The primary objective of this project is to implement image denoising using the median filter technique in both C++ and Rust programming languages. The project aims to assess and compare the performance, readability, and efficiency of the two implementations. Input images in the Portable Gray Map (PGM) format will be provided, and the goal is to develop denoised images while considering execution time, memory usage, and code readability in both languages.

### POPL Angle:
The POPL (Principles of Programming Languages) angle in this project lies in the adherence to fundamental programming principles in both C++ and Rust. Key aspects include data parallelism, immutability, proper error handling, use of functional programming constructs, modularity, and type safety. The project aligns with the principles of writing readable, maintainable, and efficient code while utilizing the features specific to each language.

### Previous Solutions:
While image denoising with median filters is a well-explored problem, the project's focus on comparing implementations in C++ and Rust provides a unique angle. While similar tasks may have been addressed previously, the specific comparison between these two languages for image denoising using median filters may not have been extensively explored.

### Differences in Solution:
The project differentiates itself by implementing the same image denoising technique in both C++ and Rust, facilitating a direct comparison. Major difference in the median filter has been described in `/Result/README.md` The differences will be highlighted in terms of language-specific features, syntax, memory management, and overall coding practices. Any optimizations made for each language will be documented, providing valuable insights into the strengths and weaknesses of the respective implementations.

### Challenges Faced:
The challenges encountered during the project may include language-specific difficulties, optimization trade-offs, and adapting the algorithm to the idioms of C++ and Rust. Differences in memory management and performance considerations specific to each language may pose challenges that will be documented and analyzed in the comparative study.

### Expected Deliverables:
1. Implementation of the median filter for image denoising in C++.
2. Implementation of the median filter for image denoising in Rust.
3. Denoised images generated by both implementations.
4. Comparative analysis report covering performance metrics, code readability, and language-specific considerations.
5. Documentation outlining the algorithms, data structures, and language-specific features utilized in each implementation.


## Software architecture:

The software architecture for the image denoising project can follow a modular structure, separating concerns for input/output, image processing, and comparison analysis.

1. Input/Output Module:
   - Responsible for handling file I/O operations, reading input images, and saving denoised images.
   - May include components for reading PGM files and writing denoised images in PGM format.

2. Image Processing Module:
   - Implements the median filter algorithm for image denoising.
   - Modified the existing median filter algorithm with higher performance results.
   - Separates the algorithmic logic from I/O operations for better modularity.
   - Handles the core functionality of processing pixels and applying the median filter.

3. Comparison Analysis Module:
   - Evaluates and compares performance metrics, code readability, and efficiency between C++ and Rust implementations.
   - Gathers data on execution time, memory usage, and any language-specific features used in each implementation.

4. Testing Component:
   - Can be a separate module or part of the Image Processing Module.
   - Involves unit tests for individual functions/methods, integration tests for modules, and possibly benchmarking for performance evaluation.
   - Testing can be both local and, if applicable, remote (especially for performance tests).

5. Reusability:
   - The input/output handling components (reading/writing PGM files) can be reused from existing libraries or code snippets.
   - If there are established median filter libraries in C++ or Rust, they can be used or adapted for the project.
   - Language-agnostic algorithms for image processing may be reusable between the C++ and Rust implementations.

6. Testing Component Placement:
   - Unit tests can be run locally during development to ensure the correctness of individual functions.
   - Integration tests, especially those involving multiple modules, can be run locally.
   - Performance tests may involve remote testing to evaluate the software's behavior under different conditions.


##   POPL Aspects:
Here are some points related to POPL (Principles of Programming Languages) aspects in the our `Rust` code:

1. Ownership in Rust:
   - The use of vectors like `arra` and `arr` involves ownership concepts. Vectors in Rust have ownership semantics, and the ownership is transferred when passing them into functions or reassigning them. The vectors are created and manipulated within the `main` function, showcasing Rust's ownership system.

2. Mutability:
   - The variables `arra`, `arr`, `row`, `col`, `numrows`, `numcols`, `max` are all marked as mutable using the `mut` keyword. This reflects Rust's emphasis on immutability by default and explicit mutability when needed. Mutable variables are modified throughout the program, demonstrating Rust's control over mutability.

3. Lifetimes:
   - The use of lifetimes is implicit in the code, particularly in the way slices are borrowed and accessed within the loops. For example, `&mut arra[row - 1][col - 1]` represents a mutable borrow with a lifetime tied to the loop iteration. Lifetimes in Rust ensure that references remain valid for a specific scope and prevent dangling references.

4. Error Handling:
   - Rust's Result type and the `?` operator are utilized for error handling throughout the code. For instance, the `File::open("mona_lisa.pgm")?` expression and other instances where `Result` is used demonstrate Rust's approach to handling errors using the Result type.

5. Pattern Matching:
   - The pattern matching capability is demonstrated in the section where the PGM file is read. The code checks if the first line of the file is "P2" and prints an error message if not. This reflects Rust's pattern matching syntax, providing a concise and expressive way to handle different cases.

6. Trait Implementation:
   - The use of traits is apparent in the code, especially with `BufRead` and `Write` traits. The `BufReader` and `BufWriter` types implement these traits, allowing seamless reading and writing operations. This showcases Rust's trait system, promoting code reuse and abstraction.

7. Array Indexing:
   - The code extensively uses array indexing, e.g., `arra[row][col]`, which is a fundamental concept in array-based programming. Rust enforces array bounds checking at runtime, preventing common errors like buffer overflows. The code's reliance on safe array indexing demonstrates Rust's commitment to memory safety.

8. Functional Programming Style:
   - The code employs functional programming style with iterator-based operations like `lines()`, `split_whitespace()`, and `sort()`. This aligns with Rust's support for functional programming paradigms, encouraging a declarative and expressive coding style.

9. File Handling:
   - The code involves file handling using the `File` type from the `std::fs` module. Rust's file handling capabilities include safe and ergonomic abstractions for working with files, aligning with the language's focus on safety and performance.

10. Performance Considerations:
   - The use of arrays for image processing and the choice of algorithms (e.g., the median filter) reflects considerations for performance. Rust's zero-cost abstractions and emphasis on performance make it suitable for such tasks, allowing the developer to write high-level code without sacrificing performance.

Difficulties faced:
One of the primary challenges we encountered during the development process was related to dataset preparation, particularly in generating the appropriate dataset for our code. The task involved resizing .pgm and .pnm image files to fit the requirements of our project. Initially, this proved to be a complex undertaking due to the unique nature of these file formats. We also had to install external software like GIMP to open such file extensions. 

